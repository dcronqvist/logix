# The D2 processor

Little endian.

Buses:
1x 16-bit address bus
1x 8-bit data bus

Registers:
1x 8-bit accumulator (a)
1x 8-bit temporary register (t)
1x 8-bit result register (r)
1x 8-bit status register (s) (flags: zero, carry, negative, overflow, interrupt mask, unused, unused, unused)
1x 16-bit program counter (pc)
1x 16-bit stack pointer (sp)
2x 8-bit index register (x, y)
1x 16-bit memory address register (mar)

ALU has data bus and temporary register as inputs, result register as output, also status register as flag output.
ALU functions:
zero (output 0)
ff (output 0xff)
fe (output 0xfe)
fc (output 0xfc)
add (bus + t)
subtract (bus - t)
bitwise and (bus & t)
bitwise or (bus | t)
bitwise exclusive or (bus ^ t)
rotate left (bus << 1)
rotate right (bus >> 1)

Addressing modes:

implicit (instruction has no operands)
immediate (instruction has an 8-bit or 16-bit immediate operand)
absolute (instruction has a 16-bit absolute address operand)
absolute,%(x/y) (instruction has a 16-bit absolute address operand and a register, final operand is the sum of the two)

Instructions:

nop (no operation)

lda #imm (load accumulator with immediate)
lda abs (load accumulator with M[abs])
lda abs,x (load accumulator with M[abs + x])
lda abs,y (load accumulator with M[abs + y])
lda (abs) (load accumulator with M[M[abs + 1] << 8 | M[abs]])
lda (abs), x (load accumulator with M[M[abs + x + 1] << 8 | M[abs + x]])
lda (abs), y (load accumulator with M[M[abs + y + 1] << 8 | M[abs + y]])
sta abs (store accumulator in M[abs])
sta abs,x (store accumulator in M[abs + x])
sta abs,y (store accumulator in M[abs + y])
sta (abs) (store accumulator in M[M[abs + 1] << 8 | M[abs]])
sta (abs), x (store accumulator in M[M[abs + x + 1] << 8 | M[abs + x]])
sta (abs), y (store accumulator in M[M[abs + y + 1] << 8 | M[abs + y]])

ldx #imm (load x with immediate)
ldx abs (load x with M[abs])
ldx abs,x (load x with M[abs + x])
ldx abs,y (load x with M[abs + y])
ldx (abs) (load x with M[M[abs + 1] << 8 | M[abs]])
ldx (abs), x (load x with M[M[abs + x + 1] << 8 | M[abs + x]])
ldx (abs), y (load x with M[M[abs + y + 1] << 8 | M[abs + y]])
stx abs (store x in M[abs])
stx abs,x (store x in M[abs + x])
stx abs,y (store x in M[abs + y])
stx (abs) (store x in M[M[abs + 1] << 8 | M[abs]])
stx (abs), x (store x in M[M[abs + x + 1] << 8 | M[abs + x]])
stx (abs), y (store x in M[M[abs + y + 1] << 8 | M[abs + y]])

ldy #imm (load y with immediate)
ldy abs (load y with M[abs])
ldy abs,x (load y with M[abs + x])
ldy abs,y (load y with M[abs + y])
ldy (abs) (load y with M[M[abs + 1] << 8 | M[abs]])
ldy (abs), x (load y with M[M[abs + x + 1] << 8 | M[abs + x]])
ldy (abs), y (load y with M[M[abs + y + 1] << 8 | M[abs + y]])
sty abs (store y in M[abs])
sty abs,x (store y in M[abs + x])
sty abs,y (store y in M[abs + y])
sty (abs) (store y in M[M[abs + 1] << 8 | M[abs]])
sty (abs), x (store y in M[M[abs + x + 1] << 8 | M[abs + x]])
sty (abs), y (store y in M[M[abs + y + 1] << 8 | M[abs + y]])

tax (transfer accumulator to x)
tay (transfer accumulator to y)
txa (transfer x to accumulator)
tya (transfer y to accumulator)

ina (increment accumulator)
inx (increment x)
iny (increment y)
inc abs (increment M[abs])
inc abs,x (increment M[abs + x])
inc abs,y (increment M[abs + y])
inc (abs) (increment M[M[abs + 1] << 8 | M[abs]])
inc (abs), x (increment M[M[abs + x + 1] << 8 | M[abs + x]])
inc (abs), y (increment M[M[abs + y + 1] << 8 | M[abs + y]])

dea (decrement accumulator)
dex (decrement x)
dey (decrement y)
dec abs (decrement M[abs])
dec abs,x (decrement M[abs + x])
dec abs,y (decrement M[abs + y])
dec (abs) (decrement M[M[abs + 1] << 8 | M[abs]])
dec (abs), x (decrement M[M[abs + x + 1] << 8 | M[abs + x]])
dec (abs), y (decrement M[M[abs + y + 1] << 8 | M[abs + y]])

adc #imm (add immediate to accumulator with carry)
adc abs (add M[abs] to accumulator with carry)
adc abs,x (add M[abs + x] to accumulator with carry)
adc abs,y (add M[abs + y] to accumulator with carry)
adc (abs) (add M[M[abs + 1] << 8 | M[abs]] to accumulator with carry)
adc (abs), x (add M[M[abs + x + 1] << 8 | M[abs + x]] to accumulator with carry)
adc (abs), y (add M[M[abs + y + 1] << 8 | M[abs + y]] to accumulator with carry)

sbc #imm (subtract immediate from accumulator with carry)
sbc abs (subtract M[abs] from accumulator with carry)
sbc abs,x (subtract M[abs + x] from accumulator with carry)
sbc abs,y (subtract M[abs + y] from accumulator with carry)
sbc (abs) (subtract M[M[abs + 1] << 8 | M[abs]] from accumulator with carry)
sbc (abs), x (subtract M[M[abs + x + 1] << 8 | M[abs + x]] from accumulator with carry)
sbc (abs), y (subtract M[M[abs + y + 1] << 8 | M[abs + y]] from accumulator with carry)

and #imm (bitwise and accumulator with immediate)
and abs (bitwise and accumulator with M[abs])
and abs,x (bitwise and accumulator with M[abs + x])
and abs,y (bitwise and accumulator with M[abs + y])
and (abs) (bitwise and accumulator with M[M[abs + 1] << 8 | M[abs]])
and (abs), x (bitwise and accumulator with M[M[abs + x + 1] << 8 | M[abs + x]])
and (abs), y (bitwise and accumulator with M[M[abs + y + 1] << 8 | M[abs + y]])

ora #imm (bitwise or accumulator with immediate)
ora abs (bitwise or accumulator with M[abs])
ora abs,x (bitwise or accumulator with M[abs + x])
ora abs,y (bitwise or accumulator with M[abs + y])
ora (abs) (bitwise or accumulator with M[M[abs + 1] << 8 | M[abs]])
ora (abs), x (bitwise or accumulator with M[M[abs + x + 1] << 8 | M[abs + x]])
ora (abs), y (bitwise or accumulator with M[M[abs + y + 1] << 8 | M[abs + y]])

eor #imm (bitwise exclusive or accumulator with immediate)
eor abs (bitwise exclusive or accumulator with M[abs])
eor abs,x (bitwise exclusive or accumulator with M[abs + x])
eor abs,y (bitwise exclusive or accumulator with M[abs + y])
eor (abs) (bitwise exclusive or accumulator with M[M[abs + 1] << 8 | M[abs]])
eor (abs), x (bitwise exclusive or accumulator with M[M[abs + x + 1] << 8 | M[abs + x]])
eor (abs), y (bitwise exclusive or accumulator with M[M[abs + y + 1] << 8 | M[abs + y]])

rol (rotate accumulator left)
ror (rotate accumulator right)

pha (push accumulator on stack)
pla (pull accumulator from stack)
phx (push x on stack)
plx (pull x from stack)
phy (push y on stack)
ply (pull y from stack)
php (push flags)
plp (pull flags)

jmp abs (jump to absolute address)
jsr abs (jump to subroutine at absolute address)
rts (return from subroutine)

jeq abs (jump to address if zero flag is set)
jne abs (jump to address if zero flag is not set)
jcs abs (jump to address if carry flag is set)
jcc abs (jump to address if carry flag is not set)
jns abs (jump to address if negative flag is set)
jnc abs (jump to address if negative flag is not set)
jvs abs (jump to address if overflow flag is set)
jvc abs (jump to address if overflow flag is not set)

cmp #imm (compare accumulator with immediate)
cmp abs (compare accumulator with M[abs])
cmp abs,x (compare accumulator with M[abs + x])
cmp abs,y (compare accumulator with M[abs + y])
cmp (abs) (compare accumulator with M[M[abs + 1] << 8 | M[abs]])
cmp (abs), x (compare accumulator with M[M[abs + x + 1] << 8 | M[abs + x]])
cmp (abs), y (compare accumulator with M[M[abs + y + 1] << 8 | M[abs + y]])

bit #imm (bitwise and accumulator with immediate, set flags)
bit abs (bitwise and accumulator with M[abs], set flags)
bit abs,x (bitwise and accumulator with M[abs + x], set flags)
bit abs,y (bitwise and accumulator with M[abs + y], set flags)
bit (abs) (bitwise and accumulator with M[M[abs + 1] << 8 | M[abs]], set flags)
bit (abs), x (bitwise and accumulator with M[M[abs + x + 1] << 8 | M[abs + x]], set flags)
bit (abs), y (bitwise and accumulator with M[M[abs + y + 1] << 8 | M[abs + y]], set flags)

clz (clear zero flag)
sez (set zero flag)
clc (clear carry flag)
sec (set carry flag)
cln (clear negative flag)
sen (set negative flag)
clv (clear overflow flag)
sev (set overflow flag)
cli (clear interrupt enable)
sei (set interrupt enable)

rti (return from interrupt)
lsp #imm (16 bit) (load sp with immediate)
brk (break, interrupt)
